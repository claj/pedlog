Exception in thread "main" Syntax error macroexpanding clojure.core/ns at (io/pedestal/log.clj:13:1).
Call to clojure.core/ns did not conform to spec.
	at clojure.lang.Compiler.checkSpecs(Compiler.java:6971)
	at clojure.lang.Compiler.macroexpand1(Compiler.java:6987)
	at clojure.lang.Compiler.macroexpand(Compiler.java:7074)
	at clojure.lang.Compiler.eval(Compiler.java:7160)
	at clojure.lang.Compiler.load(Compiler.java:7635)
	at clojure.lang.RT.loadResourceScript(RT.java:380)
	at clojure.lang.RT.loadResourceScript(RT.java:371)
	at clojure.lang.RT.load(RT.java:462)
	at clojure.lang.RT.load(RT.java:427)
	at clojure.core$load$fn__6813.invoke(core.clj:6117)
	at clojure.core$load.invokeStatic(core.clj:6116)
	at clojure.core$load.doInvoke(core.clj:6100)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5908)
	at clojure.core$load_one.invoke(core.clj:5903)
	at clojure.core$load_lib$fn__6756.invoke(core.clj:5948)
	at clojure.core$load_lib.invokeStatic(core.clj:5947)
	at clojure.core$load_lib.doInvoke(core.clj:5928)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:667)
	at clojure.core$load_libs.invokeStatic(core.clj:5985)
	at clojure.core$load_libs.doInvoke(core.clj:5969)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:667)
	at clojure.core$require.invokeStatic(core.clj:6007)
	at clojure.core$require.doInvoke(core.clj:6007)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at pedlog.core$eval241$loading__6697__auto____242.invoke(core.clj:1)
	at pedlog.core$eval241.invokeStatic(core.clj:1)
	at pedlog.core$eval241.invoke(core.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:7176)
	at clojure.lang.Compiler.eval(Compiler.java:7165)
	at clojure.lang.Compiler.load(Compiler.java:7635)
	at clojure.lang.RT.loadResourceScript(RT.java:380)
	at clojure.lang.RT.loadResourceScript(RT.java:371)
	at clojure.lang.RT.load(RT.java:462)
	at clojure.lang.RT.load(RT.java:427)
	at clojure.core$load$fn__6813.invoke(core.clj:6117)
	at clojure.core$load.invokeStatic(core.clj:6116)
	at clojure.core$load.doInvoke(core.clj:6100)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at clojure.core$load_one.invokeStatic(core.clj:5908)
	at clojure.core$load_one.invoke(core.clj:5903)
	at clojure.core$load_lib$fn__6756.invoke(core.clj:5948)
	at clojure.core$load_lib.invokeStatic(core.clj:5947)
	at clojure.core$load_lib.doInvoke(core.clj:5928)
	at clojure.lang.RestFn.applyTo(RestFn.java:142)
	at clojure.core$apply.invokeStatic(core.clj:667)
	at clojure.core$load_libs.invokeStatic(core.clj:5985)
	at clojure.core$load_libs.doInvoke(core.clj:5969)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.core$apply.invokeStatic(core.clj:667)
	at clojure.core$require.invokeStatic(core.clj:6007)
	at clojure.core$require.doInvoke(core.clj:6007)
	at clojure.lang.RestFn.invoke(RestFn.java:408)
	at user$eval224$fn__228.invoke(form-init5220620587663144865.clj:1)
	at user$eval224.invokeStatic(form-init5220620587663144865.clj:1)
	at user$eval224.invoke(form-init5220620587663144865.clj:1)
	at clojure.lang.Compiler.eval(Compiler.java:7176)
	at clojure.lang.Compiler.eval(Compiler.java:7166)
	at clojure.lang.Compiler.load(Compiler.java:7635)
	at clojure.lang.Compiler.loadFile(Compiler.java:7573)
	at clojure.main$load_script.invokeStatic(main.clj:442)
	at clojure.main$init_opt.invokeStatic(main.clj:444)
	at clojure.main$init_opt.invoke(main.clj:444)
	at clojure.main$initialize.invokeStatic(main.clj:475)
	at clojure.main$null_opt.invokeStatic(main.clj:509)
	at clojure.main$null_opt.invoke(main.clj:506)
	at clojure.main$main.invokeStatic(main.clj:588)
	at clojure.main$main.doInvoke(main.clj:551)
	at clojure.lang.RestFn.applyTo(RestFn.java:137)
	at clojure.lang.Var.applyTo(Var.java:705)
	at clojure.main.main(main.java:37)
Caused by: clojure.lang.ExceptionInfo: Call to clojure.core/ns did not conform to spec. {:clojure.spec.alpha/problems ({:path [:ns-clauses :refer-clojure :clause], :pred #{:refer-clojure}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-refer-clojure :clojure.core.specs.alpha/ns-refer-clojure], :in [3 0]} {:path [:ns-clauses :require :clause], :pred #{:require}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-require :clojure.core.specs.alpha/ns-require], :in [3 0]} {:path [:ns-clauses :import :classes :class], :pred clojure.core/simple-symbol?, :val (io.opentracing.log.Fields), :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-import :clojure.core.specs.alpha/ns-import], :in [3 6]} {:path [:ns-clauses :import :classes :package-list :classes], :reason "Insufficient input", :pred clojure.core/simple-symbol?, :val (), :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-import :clojure.core.specs.alpha/ns-import :clojure.core.specs.alpha/package-list :clojure.core.specs.alpha/package-list], :in [3 6]} {:path [:ns-clauses :use :clause], :pred #{:use}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-use :clojure.core.specs.alpha/ns-use], :in [3 0]} {:path [:ns-clauses :refer :clause], :pred #{:refer}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-refer :clojure.core.specs.alpha/ns-refer], :in [3 0]} {:path [:ns-clauses :load :clause], :pred #{:load}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-load :clojure.core.specs.alpha/ns-load], :in [3 0]} {:path [:ns-clauses :gen-class :clause], :pred #{:gen-class}, :val :import, :via [:clojure.core.specs.alpha/ns-form :clojure.core.specs.alpha/ns-gen-class :clojure.core.specs.alpha/ns-gen-class], :in [3 0]}), :clojure.spec.alpha/spec #object[clojure.spec.alpha$regex_spec_impl$reify__2509 0x5ce33a58 "clojure.spec.alpha$regex_spec_impl$reify__2509@5ce33a58"], :clojure.spec.alpha/value (io.pedestal.log "Logging via slf4j. Each logging level is a macro: trace, debug,\n  info, warn, and error. Each namespace gets its own Logger. Arguments\n  are key-value pairs, which will be printed as with 'pr'. The special\n  key :exception should have a java.lang.Throwable as its value, and\n  will be passed separately to the underlying logging API.\n  One can override the logger via JVM or ENVAR settings." (:require clojure.string) (:import (org.slf4j Logger LoggerFactory MDC) (org.slf4j.spi MDCAdapter) (com.codahale.metrics MetricRegistry Gauge Counter Histogram Meter Slf4jReporter) (com.codahale.metrics.jmx JmxReporter) (io.opentracing Scope Span SpanContext Tracer Tracer$SpanBuilder) (io.opentracing.log.Fields) (io.opentracing.util GlobalTracer) (java.util Map) (java.util.concurrent TimeUnit) (clojure.lang IFn))), :clojure.spec.alpha/args (io.pedestal.log "Logging via slf4j. Each logging level is a macro: trace, debug,\n  info, warn, and error. Each namespace gets its own Logger. Arguments\n  are key-value pairs, which will be printed as with 'pr'. The special\n  key :exception should have a java.lang.Throwable as its value, and\n  will be passed separately to the underlying logging API.\n  One can override the logger via JVM or ENVAR settings." (:require clojure.string) (:import (org.slf4j Logger LoggerFactory MDC) (org.slf4j.spi MDCAdapter) (com.codahale.metrics MetricRegistry Gauge Counter Histogram Meter Slf4jReporter) (com.codahale.metrics.jmx JmxReporter) (io.opentracing Scope Span SpanContext Tracer Tracer$SpanBuilder) (io.opentracing.log.Fields) (io.opentracing.util GlobalTracer) (java.util Map) (java.util.concurrent TimeUnit) (clojure.lang IFn)))}
	at clojure.spec.alpha$macroexpand_check.invokeStatic(alpha.clj:705)
	at clojure.spec.alpha$macroexpand_check.invoke(alpha.clj:697)
	at clojure.lang.AFn.applyToHelper(AFn.java:156)
	at clojure.lang.AFn.applyTo(AFn.java:144)
	at clojure.lang.Var.applyTo(Var.java:705)
	at clojure.lang.Compiler.checkSpecs(Compiler.java:6969)
	... 72 more
